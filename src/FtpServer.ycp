/**
 * File:	modules/FtpServer.ycp
 * Package:	Configuration of FtpServer
 * Summary:	FtpServer settings, input and output functions
 * Authors:	Jozef Uhliarik <juhliarik@suse.cz>
 *
 * $Id: FtpServer.ycp 27914 2006-02-13 14:32:08Z juhliarik $
 *
 * Representation of the configuration of FtpServer.
 * Input and output routines.
 */

{

module "FtpServer";
textdomain "ftp-server";


import "Progress";
import "Report";
import "Summary";
import "Message";
import "Popup";
import "String";
import "Mode";
import "Package";
import "CommandLine";
import "Users";
import "SuSEFirewall";
import "SuSEFirewallServices";
import "PortAliases";

/**
 * Prototypes
 */
global boolean Modified();

global boolean WriteToEditMap (string key, string value);

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * general variable for proposal
 * 
 */
global boolean proposal_valid = false;

/**
 * variable signifies if vsftpd is selected and 
 * edited via ftp-server (YaST module)
 * global boolean variable
 */
global boolean vsftpd_edit = false;

/**
 * variable signifies if vsftpd is installed and 
 * 
 * global boolean variable
 */
global boolean vsftpd_installed = false;

/**
 * variable signifies if pure-ftpd is installed and 
 * 
 * global boolean variable
 */
global boolean pureftpd_installed = false;

/**
 * variable signifies position vsftpd record
 * in structur Inetd::netd_conf  
 * -1 init value before calling Inetd::Read() 
 *
 * global integer variable
 */
global integer vsftpd_xined_id = -1;

/**
 * variable signifies if pure-ftpd is installed and 
 * in structur Inetd::netd_conf  
 * -1 init value before calling Inetd::Read() 
 * 
 * global integer variable
 */
global integer pureftpd_xined_id = -1;

/**
 * variable signifies if daemon will be started via xinetd
 * 
 * global boolean variable
 */

global boolean start_xinetd = false;

/**
 * variable signifies home dir for anonymous user
 * 
 * global string variable
 */


global string anon_homedir = "";

/**
 * variable signifies uid for anonymous user
 * 
 * global integer variable
 */

global integer anon_uid = 0;

/**
 * variable signifies sleep time during reading settings
 * 
 * internal integer variable
 */

integer sl = 500;

/**
 * variable includes user info about anonymous user
 * 
 * internal map variable
 */
map userinfo = $[]; 

/**
 * list of keys from map DEFAULT_CONFIG
 *  
 * global list <string>
 */
     
global list <string> UI_keys = ["ChrootEnable","VerboseLogging","FtpDirLocal","FtpDirAnon", "Umask", 
"UmaskAnon", "UmaskLocal", "PasMinPort", "PasMaxPort", "MaxIdleTime", "MaxClientsPerIP",
"MaxClientsNumber", "LocalMaxRate", "AnonMaxRate", "AnonAuthen", "AnonReadOnly",
"AnonCreatDirs", "Banner", "SSLEnable", "TLS", "AntiWarez", "SSL", "StartXinetd", 
"PassiveMode", "CertFile", "SSLv2", "SSLv3"];

/**
 * map of deafult values for options in UI
 *  
 * global map <string, string >
 */

global map <string, string > DEFAULT_CONFIG = $[
     "ChrootEnable"              : "NO",
     "VerboseLogging"        	 : "NO",
     "FtpDirLocal"             	 : "",  //if empty doesn't write this options via SCR
     "FtpDirAnon"             	 : "",  //if empty doesn't write this options via SCR
     "Umask"               	 : "",
     "UmaskAnon"                 : "",
     "UmaskLocal"           	 : "",
     "PasMinPort"      		 : "0",
     "PasMaxPort"                : "0",
     "MaxIdleTime"    		 : "15",
     "MaxClientsPerIP"           : "10",
     "MaxClientsNumber"      	 : "8",
     "LocalMaxRate"		 : "0",
     "AnonMaxRate"		 : "0",
     "AnonAuthen"		 : "1",  // 0 => anonymous only, 1 => authenticated only, 2=> both
     "AnonReadOnly"		 : "YES",
     "AnonCreatDirs"		 : "NO",
     "Banner"			 : "Welcome message",
     "SSLEnable"		 : "NO",
     "SSLv2"			 : "NO", //enable/disable SSL version 2 (vsftpd only)
     "SSLv3"			 : "NO", //enable/disable SSL version 3 (vsftpd only)
     //"SSLVersion"		 : "2",
     "TLS"			 : "YES",
     "AntiWarez"		 : "YES",
     "SSL"			 : "1",
     "StartXinetd"		 : "NO",
     "StartDaemon"		 : "0",  //0 = start manually, 1 = start via inetd, 2 = start via xinetd
     "PassiveMode"		 : "YES",
     "CertFile"			 : "",   //cert file for SSL connections
     //"PromisMode"		 : "NO", enable ftp client connect via passive and active mode (vsftpd)
     
];

/**
 * map <string, string > of pure-ftpd settings
 *    
 */
global map <string, string > PURE_SETTINGS = $[];


/**
 * map <string, string > of vsftpd settings
 *    
 */
global map <string, string > VS_SETTINGS = $[];

/**
 * map <string, string > of vsftpd settings
 *    
 */
global map <string, string > EDIT_SETTINGS = $[];



include "ftp-server/write_load.ycp";

/**
 * Read current pure-ftpd configuration
 *
 *  @return boolean successfull
 */
boolean ReadPUREFTPDSettings () {
    foreach (string key,  SCR::Dir(.pure-ftpd), {
	string val = (string) SCR::Read(add(.pure-ftpd, key));
	//string val = (string) select((list <string>) SCR::Read(add(.pure-ftpd, key)), 0, "");
        if (val != nil) PURE_SETTINGS[key] = val;
    });
    y2milestone("-------------PURE_SETTINGS-------------------");  
    y2milestone("pure-ftpd configuration has been read: %1", PURE_SETTINGS);
    y2milestone("---------------------------------------------");


    return true;
}

/**
 * Read current vsftpd configuration
 *
 *  @return boolean successfull
 */

boolean ReadVSFTPDSettings () {
    foreach (string key,  SCR::Dir(.vsftpd), {
	string val = (string) SCR::Read(add(.vsftpd, key));
	//string val = (string) select((list <string>) SCR::Read(add(.pure-ftpd, key)), 0, "");
        if (val != nil) VS_SETTINGS[key] = val;
    });
    y2milestone("-------------VS_SETTINGS-------------------");  
    y2milestone("VSFTPD configuration has been read: %1", VS_SETTINGS);
    y2milestone("---------------------------------------------");


    return true;
}

/**
 * Remap current pure -FtpServer configuration
 * to temporary structure
 *
 * @return boolean successfull
 */
boolean InitEDIT_SETTINGS () {
   foreach (string key, UI_keys, {
       string val = ValueUI(key, false);
       if (val != nil) EDIT_SETTINGS[key] = val;
       //if (val == nil) Popup::Message(key);; 
   });

   y2milestone("-------------EDIT_SETTINGS-------------------");  
   y2milestone("EDIT_SETTINGS configuration has been read: %1", EDIT_SETTINGS);
   y2milestone("---------------------------------------------");

   return true;
}




/**
 * Read current configuration
 *
 * @return boolean successfull
 */
boolean ReadSettings () {
  boolean result = false;
  if (vsftpd_edit) {
     result = ReadVSFTPDSettings();
  } else {
     result = ReadPUREFTPDSettings();  
  }
  if (result) {
        result = InitEDIT_SETTINGS ();
  }
  //read info about anonymous user "ftp"
  Users::SetGUI (false);
  if (Users::Read () == "") { 
     Users::SelectUserByName ("ftp");
     userinfo = Users::GetCurrentUser ();
     anon_homedir = (string) userinfo["homedirectory"]:nil;
     anon_uid     = (integer) userinfo["uidnumber"]:nil;
     //y2milestone("-------------User info-------------------");  
     //y2milestone("Users :CurrentUser %1", userinfo);
     //y2milestone("---------------------------------------------");
     if ((anon_homedir != "") && (anon_homedir != nil)) {
        if (EDIT_SETTINGS["FtpDirAnon"]:nil == "")
	   EDIT_SETTINGS["FtpDirAnon"] = anon_homedir;	
     }
  }

  //read firewall settings
  boolean progress_orig = Progress::set (false);
  SuSEFirewall::Read ();
  Progress::set (progress_orig);
  return result;
}


/**
 * Write pure-ftpd configuration to config file
 *
 * @return boolean successfull
 */
boolean WritePUREFTPDSettings () {

  foreach (string option_key, string option_val, PURE_SETTINGS, {
	SCR::Write(add(.pure-ftpd, option_key), option_val);
    });
    // This is very important
    // it flushes the cache, and stores the configuration on the disk
    SCR::Write(.pure-ftpd, nil);

    return true;
}


/**
 * Write vsftpd configuration to config file
 *
 * @return boolean successfull
*/
boolean WriteVSFTPDSettings () {

  foreach (string option_key, string option_val, VS_SETTINGS, {
	SCR::Write(add(.vsftpd, option_key), option_val);
    });
    // This is very important
    // it flushes the cache, and stores the configuration on the disk
    SCR::Write(.vsftpd, nil);

    return true;
}



/**
 * Remap UI pure-ftpd or vsftpd configuration
 * to write structure for SCR
 *
 * @return boolean successfull
*/

boolean WriteToSETTINGS () {
   foreach (string key, UI_keys, {
       ValueUI(key, true);
   });

   y2milestone("-------------PURE_SETTINGS-------------------");  
   y2milestone("pure-ftpd writing configuration : %1", PURE_SETTINGS);
   y2milestone("---------------------------------------------");

   y2milestone("-------------VS_SETTINGS-------------------");  
   y2milestone("Vsftpd writing configuration : %1", VS_SETTINGS);
   y2milestone("---------------------------------------------");
   return true;
}

/**
 * Write firewall configuration
 *
 * @return boolean successfull
*/

boolean WriteFirewallSettings() {

string port_range = "";
string active_port = "";

if (SuSEFirewall::IsStarted()) {
   if (EDIT_SETTINGS["PassiveMode"]:nil == "YES") {
      port_range = EDIT_SETTINGS["PasMinPort"]:nil +":"+ EDIT_SETTINGS["PasMaxPort"]:nil;
   } else {
      active_port = (PortAliases::IsKnownPortName("ftp-data") ? "ftp-data" : "20");
   }

   map <string, list<string> > suse_config = $[
     "tcp_ports" : [ 
        (PortAliases::IsKnownPortName("ftp") ? "ftp":"21"), 
        ((active_port != "")? active_port : port_range )],
     ];

   if (vsftpd_edit)
      return SuSEFirewallServices::SetNeededPortsAndProtocols("service:vsftpd", suse_config);
   else
      return SuSEFirewallServices::SetNeededPortsAndProtocols("service:pure-ftpd", suse_config);
} else {
   return true;
}

}

/**
 * Write value from UI 
 * to temporary structure
 *
 * @param string key of EDIT_SETTINGS map
 * @param string value of "key" EDIT_SETTINGS map
 * @return boolean successfull
*/

global boolean WriteToEditMap (string key, string value) {
  EDIT_SETTINGS[key]= value;
  return true;  
}




/**
 * Write current configuration
 *
 * @return boolean successfull
*/
boolean WriteSettings () {
  boolean result = false;
  result = WriteToSETTINGS();
  if (vsftpd_edit) {
     if (result) {
	result = WriteVSFTPDSettings();
     }
  } else {    
     if (result) {
	result = WritePUREFTPDSettings();
     }
     // write homedirectory for anonymous user (ftp)
     if (result) {
	if ((EDIT_SETTINGS["FtpDirAnon"]:nil != anon_homedir) &&
           (anon_homedir != "") && (anon_homedir != nil)) {
           string error = Users::EditUser($["homedirectory":EDIT_SETTINGS["FtpDirAnon"]:nil]);
           if ((error != nil) && (error != "")) {
              result= false;
              Popup::Error(error);
	   }
           if (result)
	      if (Users::CommitUser ()) {
		 Users::SetGUI (false);  
		 error = Users::Write();
                 if ((error != nil) && (error != "")) {
		    Popup::Error(error);
		    result = false;
                 }
              } 
	}
     }
     
  }

  if (result) {
     result = WriteFirewallSettings();

  }
  if (result) {
     // write configuration to the firewall
     boolean progress_orig = Progress::set (false);
     result = SuSEFirewall::Write ();
     Progress::set (progress_orig);
  }
  return result; 
}

/**
 * Write current configuration
 *
 * @return boolean result of function (true/false)
 */
boolean WriteXinetd () {
  boolean result = false;  
  if (vsftpd_xined_id != -1) {
     result = WriteStartViaXinetd (start_xinetd);
  }
  return result; 
}


/**
 * read value from  PURE_EDIT_SETTINGS
 * 
 * @param  string key for edit map (ID of option)
 * @return string value of key from edit map
 */

global string ValueUIEdit (string key) {
  return EDIT_SETTINGS[key]:nil;
}



/**
 */
global boolean ftps = true;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/*
 * Abort function
 * @return boolean return true if abort
 *
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}*/

/**
 * Returns whether the configuration has been modified.
 *
 * @return boolean modified
 */
global boolean GetModified() {
    return modified;
}


/**
 * Returns a confirmation popup dialog whether user wants to really abort.
 *
 * @return boolean result of Popup::ReallyAbort(GetModified()
 */
global boolean Abort() {
    return Popup::ReallyAbort(GetModified());
}

/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}



/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}



/**
 * Read all FtpServer settings
 * @return true on success
 */
global boolean Read() {

  /* FtpServer read dialog caption */
  string caption = _("Initializing FTP Configuration");
  integer steps = 2;   

  // Part for commandline - it is necessary choose daemon if both are installed
  if (Mode::commandline()) {
     vsftpd_installed = Package::Installed("vsftpd");
     pureftpd_installed = Package::Installed("pure-ftpd");

     if ((vsftpd_installed)&&(pureftpd_installed)) {
	if (CommandLine::Interactive()) {
	   CommandLine::Print(String::UnderlinedHeader(_("You have installed both daemons:"), 0));
           CommandLine::Print(_("It is necessary choose one of them for configuration."));
           CommandLine::Print(_("Do you want to configure vsftpd? (if not you choose pure-ftpd)"));
	   CommandLine::Print("");
           if (CommandLine::YesNo())
              vsftpd_edit = true;
	} else {
	   CommandLine::Error(_("You have installed both daemons. It is necessary run configuration in interactive mode."));
           return false;
	}
     }
     if ((vsftpd_installed)&&(!pureftpd_installed))
        vsftpd_edit = true;
      
     if ((!vsftpd_installed)&&(!pureftpd_installed))
        return false;
  }

    // We do not set help text here, because it was set outside
  Progress::New( caption, " ", 
    steps, [
      /* Progress stage 1/2 */
      _("Read settings from the config file"),
      /* Progress stage 2/2 */
      _("Read the previous settings")
      ], [
      /* Progress stage 1/2 */
      _("Reading the settings..."),
      Message::Finished()
      ],
      ""
  ); //end of Progress::New( caption, " "

  // read settings
  if (PollAbort()) return false;
  Progress::NextStage();
  // calling read function for reading settings form config file
  if (!ReadSettings()) Report::Error(_("Cannot Read Current Settings."));
  sleep(sl); 

  if (PollAbort()) return false;
  /* Progress finished */
  Progress::NextStage();
  sleep(sl);

  if (PollAbort()) return false;
  modified = false;
  return true;
}

/**
 * Write all FtpServer settings
 * @return true on success
 */
global boolean Write() {

  /* FtpServer read dialog caption */
  string caption = _("Saving FTP Configuration");
  integer steps = 2;

  // We do not set help text here, because it was set outside
  Progress::New(caption, " ", 
    steps, [
      /* Progress stage 1/2 */
      _("Write the settings to the config file"),
      /* Progress stage 2/2 */
      _("Write the settings for starting daemon")
      ], [
      /* Progress step 1/1 */
      _("Writing the settings..."),
      Message::Finished()
      ],
      ""
  ); //end of Progress::New(caption, " "

  // write settings
  if (PollAbort()) return false;
  Progress::NextStage();
  // write options to the config file
  if(!WriteSettings ()) Report::Error (_("Cannot write settings!"));
  sleep(sl);

  if (PollAbort()) return false;
  Progress::NextStage ();
  // write settings for starting daemon
  if (!WriteXinetd ()) Report::Error (_("Cannot write settings for xinetd!"));
  sleep(sl);

  if(PollAbort()) return false;
  /* Progress finished */
  Progress::NextStage();
  sleep(sl);

  if(PollAbort()) return false;
  return true;
}

/**
 * Get all FtpServer settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
  boolean result = true;
  foreach (string key, UI_keys, {
    string val = (string) settings[key]:nil;
    if (val != nil) EDIT_SETTINGS[key] = val;
    if (val == nil) EDIT_SETTINGS[key] = DEFAULT_CONFIG[key]:nil; 
    }
  );        
  return result;
}

/**
 * Set which daemon will be configured
 * (For use by autoinstallation.)
 * 
 * @return boolean True on success
 */
global boolean InitDaemon () {
  boolean result = true;
  //Checking if ftp daemons are installed
  integer rad_but = 0;
  integer vsftpd_init_count = 0;
  integer pureftpd_init_count = 0;
  any ret = nil;
  if (Package::Installed("vsftpd")) {
     vsftpd_init_count = vsftpd_init_count + 1;
     vsftpd_installed = true;
  }
  if (Package::Installed("pure-ftpd")) {
     pureftpd_init_count = pureftpd_init_count + 1;
     pureftpd_installed = true;
  }
  if (pureftpd_installed && vsftpd_installed) {
     if (Service::Enabled("pure-ftpd")) 
        pureftpd_init_count = pureftpd_init_count + 1;

     if (Service::Enabled("vsftpd")) 
        vsftpd_init_count = vsftpd_init_count + 1;

     //Checking status of ftp daemons

     if (Service::Status("vsftpd") == 0)
        vsftpd_init_count = vsftpd_init_count + 1;
 
     if (Service::Status("pure-ftpd") == 0)
        pureftpd_init_count = pureftpd_init_count + 1;

     if (pureftpd_init_count == vsftpd_init_count) {
        vsftpd_edit = false;
     } else if (pureftpd_init_count < vsftpd_init_count) {
        vsftpd_edit = false;
     } else {
       vsftpd_edit = true;
     }  
  } else if (pureftpd_installed && !vsftpd_installed) {
     result = true;
     vsftpd_edit = false;
  } else if (!pureftpd_installed && vsftpd_installed) {
    result = true;
    vsftpd_edit = true;
  } else {
    result = true;
    vsftpd_edit = false;
  } 
  return result;
}



/**
 * Dump the FtpServer settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
  return EDIT_SETTINGS;
}

/**
 * Create unsorted list of options
 * @return string Returnes string with RichText-formated list
 */
global define string OptionsSummary() ``{
  string S = "";
  string option = "";
  //start FTP daemon
  string value = EDIT_SETTINGS["StartDaemon"]:nil;   
  if (value == "0") {
     option = "manually";
  } else if (value == "1") {
     option = "via xinetd";
  } else {
     option = "via inetd";
  }
  S = sformat("%1<li>Start Deamon: <i>(%2)</i>", S, option);
  value = EDIT_SETTINGS["AnonAuthen"]:nil;
  if (value == "0") {
     option = "Anonymous Only";
  } else if (value == "1") {
     option = "Authenticated Only";
  } else {
     option = "Both";
  }
  S = sformat("%1<li>Access: <i>(%2)</i>", S, option);
  // anonymous dir
  if (value != "1") {
     S = sformat("%1<li>Anonymous Directory: <i>(%2)</i>", S, EDIT_SETTINGS["FtpDirAnon"]:nil);
     S = sformat("%1<li>Anonymous Read Only: <i>(%2)</i>", S, EDIT_SETTINGS["AnonReadOnly"]:nil);
     S = sformat("%1<li>Anonymous Can Create Directory: <i>(%2)</i>", S, EDIT_SETTINGS["AnonCreatDirs"]:nil);
  }
  if (S == "")
     S = _("<p><ul><i>FTP daemon is not configured.</i></ul></p>");
  return S;
}



/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define string Summary() {    
  string S = "";
  if(size(EDIT_SETTINGS) == 0) {
    /*
     * Translators: Summary head, if nothing configured
     */
    S = Summary::AddHeader(S, _("FTP daemon"));
    S = Summary::AddLine(S, Summary::NotConfigured());
  } else {
    /*
     * Translators: Summary head, if something configured
     */
    string head = sformat(_("FTP daemon %1"), (vsftpd_edit ? "vsftpd" : "pure-ftpd"));
    S = Summary::AddHeader(S, head);
    S = Summary::AddHeader(S, _("These options will be configured"));
    S = sformat("%1<ul>%2</ul></p>", S, OptionsSummary());
  }
  return S;
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**zzz
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
  if (vsftpd_edit)  
     return $[ "install":["vsftpd"], "remove":[] ];
  else
     return $[ "install":["pure-ftpd"], "remove":[] ];
}

/* EOF */
}
